# ALGORITHM

> ## 자료구조 Data Structure

- [Stack](https://github.com/euijunh/algorithm/blob/main/data-structure/stack.md)
- [Queue](https://github.com/euijunh/algorithm/blob/main/data-structure/queue.md)
- [Hashmap]()
- [Graph]()
- [Tree](https://github.com/euijunh/algorithm/blob/main/data-structure/tree.md)

> ## 알고리즘의 개념 Algorithm Concept

- ### 정렬 알고리즘
  - [선택정렬(Selection Sort)](https://github.com/euijunh/algorithm/blob/main/sort-selection-sort.md) `O(N^2)`
  - [버블정렬(Bubble Sort)](https://github.com/euijunh/algorithm/blob/main/sort-bubble-sort.md) `O(N^2)`
  - [삽입정렬(Insertion Sort)](https://github.com/euijunh/algorithm/blob/main/sort-insertion-sort.md) `O(N^2)->거의정렬된 데이터라는 가정하에 최고의속도`
  - [퀵정렬(Quick Sort)](https://github.com/euijunh/algorithm/blob/main/sort-quick-sort.md) `O(NlogN)->보장되지않음(피벗값에따라), 최악의 경우 O(N^2)`
  - [병합정렬(Merge Sort)](https://github.com/euijunh/algorithm/blob/main/sort-merge-sort.md) `O(NlogN)->보장, 추가적인배열필요(메모리비효율적)`

DFS, BFS, backtracking, DP, 순열조합 ( 재귀와 완전탐색에서 확장한 개념이므로 이것들에 대한 충분한 이해가 가장 중요 ) + 문자열 다루는 문제

> ## 시간복잡도
작성한 알고리즘의 실행시간을 예상


> ## 알고리즘 평가
**1. 시간 복잡도**

같은 코드라 하더라도 실행 환경에 다르면 각각 실행시간이 다를 수 있지만 적은 시간이 걸릴 수록 좋은평가

**2. 공간 복잡도**

한정적인 메모리 안에서 효율적으로 메모리를 사용해야 한다.

**3. 구현 복잡도**

아무리 좋은 알고리즘이라 해도 구현이 어려우면 사용이 어렵다


> 시간와 공간은 trade-off 관계인 경우가 많다. 실행시간이 줄어들려면 더 많은 메모리필요하고 더 적은 메모리를 사용하면 실행시간이 커지게 된다.
> 그러니 시간과 공간의 제약조건을 확인하고 구현을 간단하게 할지말지를 결정해야 한다


















