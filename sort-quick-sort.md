# 퀵 정렬(Quick Sort)

`시간 복잡도 O(N^2)을 가지는 선택, 버블, 삽입 정렬 알고리즘 일반적으로 사용하기 어려울 정도로 성능이 안좋기 때문에 더 빠른 알고리즘이 필요한다 바로 퀵 정렬이다.` 

> ### O(N * logN) => 평균 속도이므로 보장하지는 않는다. 최악의 경우 시간 복잡도는 O(N^2)

퀵 정렬은 문제가 이미 정렬이 되어있다면 시간 복잡도는 O(N^2)에 가까운 시간복잡도가 나옵니다. => 정렬되어 있는경우 삽입 정렬을 활용하면 빠른 정렬을 할 수 있습니다. 
=> 그래서 정렬할 문제의 특성에 따라 알맞은 정렬 알고리즘을 사용해야한다.

`퀵정렬은 unstable 한 정렬 알고리즘 => 중복 값이 있으면 정렬된 후에 순서가 초기 순서와 다를 수 있다`

```
단순히 이미 정렬이나 역정렬된 상태로만 입력이 주어져도 퀵 정렬이 감당할 수 없어 평균 시간복잡도는 O(NlogN)이 아닌 최악의 케이스의 시간복잡도인 O(N^2)을 만들 수 있습니다.
이를 회피하는 방법으로 피벗으로 중앙값의 중앙값 고르기, 재귀가 깊어지면 다른 정렬을 사용하기, 랜덤으로 섞은 뒤에 수행하기 등이 있지만 정말 잘 구현하지 않으면 여전히 효율이 매우 안 좋습니다.
그래서 퀵 정렬은 어떤 알고리즘 문제에도 사용하지 않는 것이 좋습니다. 
수가 중복되지 않기 때문에 랜덤으로 섞기나 피벗을 가운데에 두는 것 등은 비교적 잘 되는 문제가 있기는 하지만, 굳이 안전하고 어디서든 쓸 수 있는 방법들을 놔두고 위험한 길을 택할 필요는 없습니다.
직접 구현할 거라면 병합 정렬이 가장 쉽고 디버깅하기도 용이하다는 의견이 많습니다.
```

퀵정렬은 분할정복 알고리즘으로 문제를 두개의 문제로 분할하게되는데 피벗(Pivot)이라고 하는 기준 값을 기준으로 큰값과 작은값의 위치를 바꿔주면서 문제배열을 2개로 나눠줍니다. 
(피벗은 보통 첫 번째 원소로 사용합니다.)


> 피벗보다 큰값을 왼쪽(배열의시작)에서부터 탐색하고 작은값을 오른쪽(배열의끝)에서부터 탐색해서 그 두 값을 바꿔줍니다. 작은값의 인덱스가 큰값의 인덱스보다 더 작을때(엇갈렸을때) 즉, 겹쳤을 때는 피벗과 작은 값을 서로 바꿔줍니다.
이러면 피벗은 정렬이 되었다고 볼 수 있습니다(피벗을 기준으로 왼쪽은 피벗보다 작은값들이고 오른쪽은 피벗보다 큰값들이다). 그래서 피벗을 기준으로 배열의 2개로 나뉘게 됩니다.
그러면 다시 분할된 2개의 배열의 각각 첫번째 값을 피벗으로 설정(2개의 피벗)해서 왼쪽과 오른쪽 배열에서 반복적으로 같은 과정을 해주게되면 정렬이 되게 됩니다.



---

```js
// 피벗값을 기준으로 큰값과 작은값을 반복적으로 바꾸는 연산을 통해 피벗보다 작은값은 피벗왼쪽에 큰값을 오른쪽에 있도록
// 엇갈리는 경우 더 왼쪽에 있는 값과 피벗값을 바꿔준다(더 왼쪽이란 피벗보다 작은 값이라는 의미)

function sortFunc(nums, start, end) {
  if (start >= end) { // 배열의 원소가 하나인 경우 정렬X
    return;
 }

  // start => 피벗은 첫 번째 원소
  let l = start+1; // 좌측에서 우측으로 큰값을 찾는 키
  let r = end; // 우측에서 좌측으로 작은값을 찾는 키
  let temp;
	
  while(l <= r) { // 엇갈릴 때까지 반복(분할될 때까지)
    // 좌측에서 우측으로 큰값 찾기
    while(l <= end && nums[start] >= nums[l]) { // 피벗값보다 큰 값을 만날 때까지 오른쪽으로 이동
      l++;
    }
    // 우측에서 좌측으로 작은값 찾기
    while(r > start && nums[start] <= nums[r]) { // 피벗값보다 작은 값을 만날 때까지 왼쪽으로 이동
      r--;
    }

    if(l > r) { // 현재 엇갈린 상태면 피벗값과 교체 
      if(start !== r) {
        temp = nums[r];
        nums[r] = nums[start];
        nums[start] = temp;
      }
    } else { // 엇갈리지 않았다면 l와 r를 교체 
      temp = nums[l];
      nums[l] = nums[r];
      nums[r] = temp;
    }
  } 

  sortFunc(nums, start, r-1); // 왼쪽 정렬
  sortFunc(nums, r+1, end); // 오른쪽 정렬
}

let nums = [10,8,5,3,1];
sortFunc(nums, 0, (nums.length-1));
console.log(nums.join(' '));
```

> 아래 퀵 정렬은 in place 방법이 아니기 때문에 별도의 메모리 공간이 필요하므로 데이터의 양이 많으면 공간적인 낭비가 심하지만 
중복되는 데이터를 순차적으로 pivot에 넣어주기 때문에 정렬 전 중복 데이터의 순서가 바뀌지 않는 stable한 정렬을 구현할 수 있다.
아래코드는 직관적이고 구현도 비교적 쉽지만 메모리 공간의 낭비가 심하기 때문에 위의 코드처럼 in place 방법이 더 좋은 성능이 가지고 있다.

```js
function sortFunc(nums) {
  if (nums.length < 2) {
    return nums;
  }

  const pivot = nums[0];
  const left = [];
  const right = [];

  for (let i = 1; i < nums.length; i++) {
    if (nums[i] <= pivot) left.push(nums[i]);
    else right.push(nums[i]);
  }

  const lSorted = sortFunc(left);
  const rSorted = sortFunc(right);
  return [...lSorted, pivot, ...rSorted];
};

let nums = [10,8,5,3,1];
console.log(sortFunc(nums).join(' '));
```
